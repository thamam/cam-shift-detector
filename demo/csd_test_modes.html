<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSD Test Modes — A/B/C Mock</title>
<style>
  :root { --gap: 12px; --pad: 12px; --bg:#0b0c10; --fg:#e6e6e6; --accent:#66fcf1; --muted:#c5c6c7; }
  html, body { margin:0; padding:0; background:var(--bg); color:var(--fg); font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, Apple Color Emoji, Segoe UI Emoji; }
  header { display:flex; align-items:center; justify-content:space-between; padding: var(--pad); border-bottom:1px solid #222; }
  h1 { margin:0; font-size:16px; font-weight:600; letter-spacing:0.3px; }
  .accent { color: var(--accent); }
  .container { padding: var(--pad); display:grid; gap: var(--gap); }
  .row { display:flex; gap:var(--gap); flex-wrap:wrap; }
  .panel { background:#111; border:1px solid #222; border-radius:12px; padding: var(--pad); flex:1; min-width:280px; }
  .controls label { display:block; margin-bottom:6px; color:var(--muted); }
  input[type="file"] { width:100%; }
  .tabs { display:flex; gap:8px; flex-wrap:wrap; }
  .tab { padding:8px 12px; border-radius:999px; border:1px solid #333; cursor:pointer; color:var(--muted); user-select:none; }
  .tab.active { color:var(--fg); border-color:var(--accent); box-shadow:0 0 0 1px var(--accent) inset; }
  .mode { display:none; }
  .mode.active { display:block; }
  canvas { background:#000; border-radius:8px; width:100%; height:auto; max-height:70vh; }
  .stat { font-variant-numeric: tabular-nums; }
  .small { color:var(--muted); font-size:12px; }
  button, select, input[type="range"] { background:#151515; border:1px solid #333; color:var(--fg); border-radius:8px; padding:6px 10px; }
  button:hover { border-color:#444; }
  .split { display:grid; grid-template-columns:1fr 1fr; gap:var(--gap); }
  .kpi { display:flex; gap:16px; flex-wrap:wrap; }
  .kpi div { background:#0d0d0d; border:1px solid #222; padding:8px 10px; border-radius:8px; }
  .muted { color:var(--muted); }
  .footer { color:#889; font-size:11px; text-align:right; padding:8px var(--pad) 12px; }
  .note { background:#0d0f12; border-left:3px solid var(--accent); padding:8px 10px; border-radius:6px; }
</style>
</head>
<body>
<header>
  <h1>CSD Debug Modes <span class="accent">A / B / C</span> — UI Mock</h1>
  <div class="small muted">Local-only. No uploads. Test interactions and visuals.</div>
</header>

<div class="container">
  <div class="tabs">
    <div class="tab active" data-tab="modeA">Mode A: Side-by-side</div>
    <div class="tab" data-tab="modeB">Mode B: Baseline playback</div>
    <div class="tab" data-tab="modeC">Mode C: Alpha blend</div>
  </div>

  <!-- Global loader -->
  <div class="panel">
    <div class="row">
      <div class="controls" style="flex:1; min-width:280px;">
        <label>Load images (PNG/JPG). Multi-select allowed.</label>
        <input id="fileInput" type="file" accept="image/*" multiple />
        <div class="small muted" style="margin-top:6px;">Tip: pick 2–10 frames to simulate a sequence.</div>
      </div>
      <div class="panel" style="flex:1;">
        <div class="note small">This mock uses simple image-space operations:
          <ul>
            <li>Resizes to a working canvas (default 960px width) for consistency.</li>
            <li>MSE and abs-diff are computed per pixel on RGBA.</li>
            <li>No Charuco or CSD solver. Swap modules later with real outputs.</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <!-- Mode A -->
  <div id="modeA" class="mode active panel">
    <h3>Mode A — Side-by-side comparison</h3>
    <div class="row">
      <div class="panel" style="flex:1;">
        <div class="row" style="align-items:center; gap:8px;">
          <label class="small">Left image index:</label>
          <select id="aLeft"></select>
          <label class="small">Right image index:</label>
          <select id="aRight"></select>
          <button id="aSwap">Swap</button>
        </div>
        <div class="split" style="margin-top:8px;">
          <canvas id="aLeftCanvas"></canvas>
          <canvas id="aRightCanvas"></canvas>
        </div>
        <div class="kpi" style="margin-top:8px;">
          <div><strong>MSE</strong>: <span id="aMSE" class="stat">—</span></div>
          <div class="small muted">Images auto-resized for metric.</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Mode B -->
  <div id="modeB" class="mode panel">
    <h3>Mode B — Baseline frame playback</h3>
    <div class="row" style="align-items:center; gap:8px;">
      <label class="small">Baseline index:</label>
      <select id="bBaseline"></select>
      <label class="small">Current index:</label>
      <select id="bCurrent"></select>
      <button id="bPrev">Prev</button>
      <button id="bNext">Next</button>
      <label class="small">Diff amplification:</label>
      <input id="bAmp" type="range" min="1" max="8" value="2" />
      <span id="bAmpLabel" class="small muted">×2</span>
    </div>
    <div class="split" style="margin-top:8px;">
      <canvas id="bBaseCanvas"></canvas>
      <canvas id="bCurrCanvas"></canvas>
    </div>
    <div style="margin-top:8px;">
      <label class="small">Abs-diff heatmap</label>
      <canvas id="bDiffCanvas"></canvas>
    </div>
    <div class="kpi" style="margin-top:8px;">
      <div><strong>MSE</strong>: <span id="bMSE" class="stat">—</span></div>
      <div class="small muted">Arrow correspondences are not implemented in this mock.</div>
    </div>
  </div>

  <!-- Mode C -->
  <div id="modeC" class="mode panel">
    <h3>Mode C — Alpha blend A/B</h3>
    <div class="row" style="align-items:center; gap:8px;">
      <label class="small">Image A index:</label>
      <select id="cA"></select>
      <label class="small">Image B index:</label>
      <select id="cB"></select>
      <label class="small">α</label>
      <input id="cAlpha" type="range" min="0" max="100" value="50" />
      <span id="cAlphaLabel" class="small muted">0.50</span>
    </div>
    <div style="margin-top:8px;">
      <canvas id="cBlendCanvas"></canvas>
    </div>
  </div>

  <div class="footer">Mock only. Replace metric and diff stubs with real CSD/Charuco pipelines later.</div>
</div>

<script>
(function(){
  const tabs = document.querySelectorAll('.tab');
  const modes = document.querySelectorAll('.mode');
  tabs.forEach(t => t.addEventListener('click', () => {
    tabs.forEach(x => x.classList.remove('active'));
    t.classList.add('active');
    const id = t.dataset.tab;
    modes.forEach(m => m.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    // trigger redraw for active mode
    renderAll();
  }));

  // Global image store
  const store = {
    files: [],
    bitmaps: [],   // ImageBitmap[]
    maxW: 960
  };

  const fileInput = document.getElementById('fileInput');
  fileInput.addEventListener('change', async (e) => {
    store.files = Array.from(e.target.files || []);
    store.bitmaps = [];
    for (const f of store.files) {
      const bmp = await createImageBitmap(await f.arrayBufferToBlob());
      store.bitmaps.push(bmp);
    }
    populateSelectors();
    renderAll();
  });

  // Polyfill helper: ArrayBuffer -> Blob for createImageBitmap
  if (!ArrayBuffer.prototype.toBlob) {
    ArrayBuffer.prototype.toBlob = function(type="image/png"){ return new Blob([this], {type}); }
  }
  if (!File.prototype.arrayBufferToBlob) {
    File.prototype.arrayBufferToBlob = async function(){ return new Blob([new Uint8Array(await this.arrayBuffer())], {type:this.type}); }
  }
  if (!ArrayBuffer.prototype.arrayBufferToBlob) {
    ArrayBuffer.prototype.arrayBufferToBlob = async function(type="image/png"){ return new Blob([new Uint8Array(this)], {type}); }
  }

  // Mode A elements
  const aLeftSel = document.getElementById('aLeft');
  const aRightSel = document.getElementById('aRight');
  const aLeftCanvas = document.getElementById('aLeftCanvas');
  const aRightCanvas = document.getElementById('aRightCanvas');
  const aMSE = document.getElementById('aMSE');
  document.getElementById('aSwap').addEventListener('click', () => {
    const li = aLeftSel.value, ri = aRightSel.value;
    aLeftSel.value = ri; aRightSel.value = li;
    renderA();
  });
  aLeftSel.addEventListener('change', renderA);
  aRightSel.addEventListener('change', renderA);

  // Mode B elements
  const bBaselineSel = document.getElementById('bBaseline');
  const bCurrentSel = document.getElementById('bCurrent');
  const bPrev = document.getElementById('bPrev');
  const bNext = document.getElementById('bNext');
  const bAmp = document.getElementById('bAmp');
  const bAmpLabel = document.getElementById('bAmpLabel');
  const bBaseCanvas = document.getElementById('bBaseCanvas');
  const bCurrCanvas = document.getElementById('bCurrCanvas');
  const bDiffCanvas = document.getElementById('bDiffCanvas');
  const bMSE = document.getElementById('bMSE');
  bBaselineSel.addEventListener('change', () => syncCurrentToBaseline());
  bCurrentSel.addEventListener('change', renderB);
  bPrev.addEventListener('click', () => stepB(-1));
  bNext.addEventListener('click', () => stepB(1));
  bAmp.addEventListener('input', () => { bAmpLabel.textContent = '×' + bAmp.value; renderB(); });

  // Mode C elements
  const cASel = document.getElementById('cA');
  const cBSel = document.getElementById('cB');
  const cAlpha = document.getElementById('cAlpha');
  const cAlphaLabel = document.getElementById('cAlphaLabel');
  const cBlendCanvas = document.getElementById('cBlendCanvas');
  cASel.addEventListener('change', renderC);
  cBSel.addEventListener('change', renderC);
  cAlpha.addEventListener('input', () => { cAlphaLabel.textContent = (cAlpha.value/100).toFixed(2); renderC(); });

  function populateSelectors(){
    const n = store.bitmaps.length;
    const opts = Array.from({length:n}, (_,i)=> `<option value="${i}">${i}</option>`).join('');
    [aLeftSel, aRightSel, bBaselineSel, bCurrentSel, cASel, cBSel].forEach(sel => {
      sel.innerHTML = opts;
      if (n>0) sel.value = 0;
    });
    if (n>1) {
      aRightSel.value = 1;
      bCurrentSel.value = 1;
      cBSel.value = 1;
    }
  }

  function stepB(delta){
    const n = store.bitmaps.length;
    if (n === 0) return;
    let idx = parseInt(bCurrentSel.value || '0', 10);
    idx = (idx + delta + n) % n;
    bCurrentSel.value = idx;
    renderB();
  }

  function syncCurrentToBaseline(){
    // If current == baseline, move current to next if exists
    if (bCurrentSel.value === bBaselineSel.value) {
      const n = store.bitmaps.length;
      let idx = parseInt(bBaselineSel.value || '0', 10);
      bCurrentSel.value = String((idx + 1) % Math.max(1,n));
    }
    renderB();
  }

  function renderAll(){
    renderA();
    renderB();
    renderC();
  }

  // Utility: draw ImageBitmap resized to max width into canvas, preserving aspect ratio
  function drawBitmapToCanvas(bmp, canvas, maxW){
    const ratio = bmp.width / bmp.height;
    const w = Math.min(maxW, bmp.width);
    const h = Math.round(w / ratio);
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,w,h);
    ctx.drawImage(bmp, 0, 0, w, h);
  }

  function getImageData(canvas){
    const ctx = canvas.getContext('2d');
    return ctx.getImageData(0,0,canvas.width,canvas.height);
  }

  function computeMSE(imgA, imgB){
    const n = Math.min(imgA.data.length, imgB.data.length);
    let acc = 0;
    for (let i=0; i<n; i++){
      const d = imgA.data[i] - imgB.data[i];
      acc += d*d;
    }
    return acc / n;
  }

  function drawDiffHeatmap(imgA, imgB, canvas, amp=2){
    const w = Math.min(imgA.width, imgB.width);
    const h = Math.min(imgA.height, imgB.height);
    canvas.width = w; canvas.height = h;
    const out = new ImageData(w, h);
    const n = w*h*4;
    for (let i=0; i<n; i+=4){
      const dr = Math.abs(imgA.data[i] - imgB.data[i]);
      const dg = Math.abs(imgA.data[i+1] - imgB.data[i+1]);
      const db = Math.abs(imgA.data[i+2] - imgB.data[i+2]);
      // simple mapping: sum diff amplified, clamp
      const v = Math.min(255, (dr+dg+db)/3 * amp);
      // pseudo heatmap: red channel carries diff
      out.data[i] = v;
      out.data[i+1] = 0;
      out.data[i+2] = 0;
      out.data[i+3] = 255;
    }
    const ctx = canvas.getContext('2d');
    ctx.putImageData(out, 0, 0);
  }

  function renderA(){
    const n = store.bitmaps.length;
    if (n === 0) { aMSE.textContent = '—'; return; }
    const li = Math.min(n-1, parseInt(aLeftSel.value || '0',10));
    const ri = Math.min(n-1, parseInt(aRightSel.value || '0',10));
    drawBitmapToCanvas(store.bitmaps[li], aLeftCanvas, store.maxW);
    drawBitmapToCanvas(store.bitmaps[ri], aRightCanvas, store.maxW);
    // compute MSE on matched dims
    const w = Math.min(aLeftCanvas.width, aRightCanvas.width);
    const h = Math.min(aLeftCanvas.height, aRightCanvas.height);
    if (w===0 || h===0) { aMSE.textContent = '—'; return; }
    // make temp canvases to uniform size
    const tA = document.createElement('canvas'); tA.width=w; tA.height=h;
    const tB = document.createElement('canvas'); tB.width=w; tB.height=h;
    tA.getContext('2d').drawImage(aLeftCanvas, 0,0,w,h);
    tB.getContext('2d').drawImage(aRightCanvas,0,0,w,h);
    const imgA = tA.getContext('2d').getImageData(0,0,w,h);
    const imgB = tB.getContext('2d').getImageData(0,0,w,h);
    const mse = computeMSE(imgA, imgB);
    aMSE.textContent = mse.toFixed(2);
  }

  function renderB(){
    const n = store.bitmaps.length;
    if (n === 0) { bMSE.textContent = '—'; return; }
    const bi = Math.min(n-1, parseInt(bBaselineSel.value || '0',10));
    const ci = Math.min(n-1, parseInt(bCurrentSel.value || '0',10));
    drawBitmapToCanvas(store.bitmaps[bi], bBaseCanvas, store.maxW);
    drawBitmapToCanvas(store.bitmaps[ci], bCurrCanvas, store.maxW);
    // uniform size
    const w = Math.min(bBaseCanvas.width, bCurrCanvas.width);
    const h = Math.min(bBaseCanvas.height, bCurrCanvas.height);
    if (w===0 || h===0) { bMSE.textContent = '—'; return; }
    const tA = document.createElement('canvas'); tA.width=w; tA.height=h;
    const tB = document.createElement('canvas'); tB.width=w; tB.height=h;
    tA.getContext('2d').drawImage(bBaseCanvas,0,0,w,h);
    tB.getContext('2d').drawImage(bCurrCanvas,0,0,w,h);
    const imgA = tA.getContext('2d').getImageData(0,0,w,h);
    const imgB = tB.getContext('2d').getImageData(0,0,w,h);
    const mse = computeMSE(imgA, imgB);
    bMSE.textContent = mse.toFixed(2);
    drawDiffHeatmap(imgA, imgB, bDiffCanvas, parseInt(bAmp.value, 10));
  }

  function renderC(){
    const n = store.bitmaps.length;
    if (n === 0) return;
    const ai = Math.min(n-1, parseInt(cASel.value || '0',10));
    const bi = Math.min(n-1, parseInt(cBSel.value || '0',10));
    const bmpA = store.bitmaps[ai];
    const bmpB = store.bitmaps[bi];
    const w = Math.min(store.maxW, Math.min(bmpA.width, bmpB.width));
    const h = Math.round(w / Math.max(bmpA.width/bmpA.height, bmpB.width/bmpB.height));
    cBlendCanvas.width = w; cBlendCanvas.height = h;
    const ctx = cBlendCanvas.getContext('2d');
    ctx.clearRect(0,0,w,h);
    const alpha = cAlpha.value / 100;
    // Draw A
    ctx.globalAlpha = alpha;
    ctx.drawImage(bmpA, 0,0,w,h);
    // Draw B
    ctx.globalAlpha = 1 - alpha;
    ctx.drawImage(bmpB, 0,0,w,h);
    ctx.globalAlpha = 1;
  }

  // initial empty populations
  populateSelectors();
  renderAll();
})();
</script>
</body>
</html>
