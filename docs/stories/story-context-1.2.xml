<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.2</storyId>
    <title>Feature Extractor</title>
    <status>Ready</status>
    <generatedAt>2025-10-21</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-1.2.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>camera movement detection system</asA>
    <iWant>extract ORB features from camera images using binary masks and store baseline features</iWant>
    <soThat>movement detection can compare current frames to a reference baseline and identify camera displacement</soThat>
    <tasks>
      <task id="1" ac="1.2.1,1.2.4">
        <title>Create FeatureExtractor class</title>
        <subtasks>
          <subtask id="1.1">Define __init__(self, min_features_required=50) - initialize ORB detector</subtask>
          <subtask id="1.2">Initialize OpenCV ORB with default parameters (or from config)</subtask>
          <subtask id="1.3">Implement extract_features(image, mask) - extract ORB keypoints and descriptors</subtask>
          <subtask id="1.4">Validate image format (H×W×3, uint8, NumPy array)</subtask>
          <subtask id="1.5">Validate mask format (H×W, uint8, NumPy array, matches image dimensions)</subtask>
        </subtasks>
      </task>
      <task id="2" ac="1.2.2,1.2.3">
        <title>Implement baseline management</title>
        <subtasks>
          <subtask id="2.1">Implement set_baseline(image, mask) - capture and store baseline features</subtask>
          <subtask id="2.2">Validate feature count ≥ min_features_required (default 50)</subtask>
          <subtask id="2.3">Raise ValueError if insufficient features detected</subtask>
          <subtask id="2.4">Implement get_baseline() - return stored baseline features</subtask>
          <subtask id="2.5">Raise RuntimeError if baseline not set when get_baseline() called</subtask>
          <subtask id="2.6">Store baseline as tuple: (keypoints, descriptors)</subtask>
        </subtasks>
      </task>
      <task id="3" ac="1.2.5">
        <title>Implement error handling</title>
        <subtasks>
          <subtask id="3.1">Validate image is NumPy array with shape (H, W, 3) and dtype uint8</subtask>
          <subtask id="3.2">Validate mask is NumPy array with shape (H, W) and dtype uint8</subtask>
          <subtask id="3.3">Validate mask dimensions match image dimensions (height, width)</subtask>
          <subtask id="3.4">Raise descriptive ValueError for format violations</subtask>
        </subtasks>
      </task>
      <task id="4" ac="all">
        <title>Unit tests</title>
        <subtasks>
          <subtask id="4.1">Test successful feature extraction with valid image and mask</subtask>
          <subtask id="4.2">Test baseline capture with sufficient features (≥50)</subtask>
          <subtask id="4.3">Test baseline capture failure with insufficient features (&lt;50)</subtask>
          <subtask id="4.4">Test get_baseline() returns stored baseline correctly</subtask>
          <subtask id="4.5">Test get_baseline() raises error when baseline not set</subtask>
          <subtask id="4.6">Test error cases (invalid image format, invalid mask format, dimension mismatch)</subtask>
          <subtask id="4.7">Test edge cases (minimal features, maximum features, various mask patterns)</subtask>
        </subtasks>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1.2.1">
      <title>ORB Feature Extraction</title>
      <description>FeatureExtractor extracts ORB keypoints and descriptors from full images using binary masks (mask parameter) where 255=detect features, 0=ignore</description>
    </criterion>
    <criterion id="1.2.2">
      <title>Baseline Storage</title>
      <description>FeatureExtractor stores baseline features (keypoints + descriptors) in memory for comparison; provides set_baseline(image, mask) and get_baseline() methods</description>
    </criterion>
    <criterion id="1.2.3">
      <title>Feature Count Validation</title>
      <description>Validates that ≥50 features are detected during baseline capture; raises ValueError if insufficient features (prevents unreliable detection)</description>
    </criterion>
    <criterion id="1.2.4">
      <title>Current Features Extraction</title>
      <description>Provides extract_features(image, mask) method that returns (keypoints, descriptors) tuple for current frame analysis</description>
    </criterion>
    <criterion id="1.2.5">
      <title>Error Handling</title>
      <description>Raises appropriate exceptions for: invalid image format (not NumPy array, wrong shape/dtype), invalid mask format (not 2D uint8 array matching image dimensions), baseline not set when calling get_baseline(), insufficient features (&lt;50) during baseline capture</description>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <artifact>
        <path>docs/tech-spec-epic-MVP-001.md</path>
        <title>Technical Specification - Camera Movement Detection Module</title>
        <section>Services and Modules</section>
        <snippet>FeatureExtractor module (src/feature_extractor.py): Extract/manage ORB features, store baseline. Inputs: Full image, binary mask. Outputs: Keypoints, descriptors. Integration with StaticRegionManager for mask-based feature extraction.</snippet>
      </artifact>
      <artifact>
        <path>docs/tech-spec-epic-MVP-001.md</path>
        <title>Technical Specification - Camera Movement Detection Module</title>
        <section>Data Models and Contracts</section>
        <snippet>Feature Data Structures: ORB Keypoints (List[cv2.KeyPoint]), ORB Descriptors (np.ndarray, shape: (n_features, 32), dtype: uint8), Baseline Features Tuple (Tuple[List[cv2.KeyPoint], np.ndarray]). Configuration includes min_features_required: 50 (minimum ORB features in ROI).</snippet>
      </artifact>
      <artifact>
        <path>docs/tech-spec-epic-MVP-001.md</path>
        <title>Technical Specification - Camera Movement Detection Module</title>
        <section>APIs and Interfaces</section>
        <snippet>CameraMovementDetector.set_baseline(image_array) method captures initial baseline features during setup phase. Raises ValueError if insufficient features detected (&lt;50). This requirement propagates to FeatureExtractor.set_baseline() implementation.</snippet>
      </artifact>
      <artifact>
        <path>docs/stories/story-1.1.md</path>
        <title>Story 1.1: Static Region Manager (Completed)</title>
        <section>Integration Pattern</section>
        <snippet>StaticRegionManager provides binary masks via get_static_mask(image_shape) method. Returns H×W uint8 array where 255=static region (detect features), 0=dynamic region (ignore). Mask-based architecture allows FeatureExtractor to use masks directly with OpenCV ORB.detectAndCompute(image, mask=mask).</snippet>
      </artifact>
      <artifact>
        <path>docs/MVP_Camera_Movement_Detection_SIMPLIFIED.md</path>
        <title>Simplified MVP PRD - Camera Movement Detection</title>
        <section>4.2 Feature Extraction Module</section>
        <snippet>ORB feature detection with binary mask support. Baseline storage for reference features. Minimum feature count validation (≥50) to ensure reliable detection. Direct integration with static region masks from StaticRegionManager.</snippet>
      </artifact>
    </docs>
    <code>
      <artifact>
        <path>src/static_region_manager.py</path>
        <kind>service</kind>
        <symbol>StaticRegionManager</symbol>
        <lines>18-145</lines>
        <reason>Story 1.1 dependency - provides binary masks for feature extraction. FeatureExtractor will call get_static_mask(image_shape) to obtain masks for ORB.detectAndCompute()</reason>
      </artifact>
      <artifact>
        <path>src/static_region_manager.py</path>
        <kind>method</kind>
        <symbol>StaticRegionManager.get_static_mask</symbol>
        <lines>91-123</lines>
        <reason>Key integration point - returns binary mask (H×W, uint8) where 255=static region, 0=dynamic. FeatureExtractor uses this mask to focus feature detection on static areas.</reason>
      </artifact>
      <artifact>
        <path>tests/test_static_region_manager.py</path>
        <kind>test</kind>
        <symbol>test_static_region_manager</symbol>
        <lines>1-504</lines>
        <reason>Reference testing patterns: Arrange-Act-Assert structure, helper functions (create_temp_config, create_test_image), comprehensive coverage (30 tests), pytest framework usage, error message validation.</reason>
      </artifact>
      <artifact>
        <path>tests/test_static_region_manager.py</path>
        <kind>helper</kind>
        <symbol>create_test_image</symbol>
        <lines>42-52</lines>
        <reason>Reusable test helper pattern for creating random BGR images. Similar helper will be needed for FeatureExtractor tests to generate test images with varying feature counts.</reason>
      </artifact>
    </code>
    <dependencies>
      <python>
        <package name="numpy" version="&gt;=1.24.0,&lt;2.0.0">Array operations, image/mask representation, descriptor arrays</package>
        <package name="opencv-python" version="&gt;=4.8.0,&lt;5.0.0">ORB feature detection via cv2.ORB_create(), detectAndCompute() with mask support</package>
        <package name="pytest" version="&gt;=7.0.0">Testing framework</package>
        <package name="pytest-cov" version="&gt;=4.0.0">Code coverage reporting</package>
      </python>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Black-box API design: FeatureExtractor should expose minimal public interface (extract_features, set_baseline, get_baseline) with implementation details hidden</constraint>
    <constraint>Mask-based architecture: Must accept binary masks from StaticRegionManager, not crop images. Use full image + mask for OpenCV ORB.detectAndCompute(image, mask=mask)</constraint>
    <constraint>Minimum feature validation: Must enforce min_features_required (default 50) during baseline capture to prevent unreliable detection</constraint>
    <constraint>Data structure compatibility: Keypoints must be cv2.KeyPoint objects, descriptors must be np.ndarray (n_features × 32, uint8) matching OpenCV ORB output format</constraint>
    <constraint>Error handling: Comprehensive input validation with descriptive error messages. Raise ValueError for format violations, RuntimeError for state errors (baseline not set)</constraint>
    <constraint>No side effects: Pure functional approach - no file I/O, no logging to external systems, return values directly (baseline stored in memory only)</constraint>
    <constraint>Testing coverage: Minimum 80% code coverage with pytest, comprehensive test suite covering all acceptance criteria</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>StaticRegionManager.get_static_mask</name>
      <kind>method</kind>
      <signature>get_static_mask(self, image_shape: tuple) -&gt; np.ndarray</signature>
      <path>src/static_region_manager.py:91-123</path>
      <description>Returns binary mask (H×W, uint8) where 255=static region, 0=dynamic. FeatureExtractor passes this mask to ORB.detectAndCompute() to focus on static areas.</description>
    </interface>
    <interface>
      <name>FeatureExtractor.__init__</name>
      <kind>constructor</kind>
      <signature>__init__(self, min_features_required: int = 50)</signature>
      <path>src/feature_extractor.py (to be created)</path>
      <description>Initialize ORB detector with cv2.ORB_create(). Store min_features_required threshold. Initialize baseline_features to None.</description>
    </interface>
    <interface>
      <name>FeatureExtractor.extract_features</name>
      <kind>method</kind>
      <signature>extract_features(self, image: np.ndarray, mask: np.ndarray) -&gt; Tuple[List[cv2.KeyPoint], np.ndarray]</signature>
      <path>src/feature_extractor.py (to be created)</path>
      <description>Extract ORB features from image using mask. Validates image (H×W×3, uint8) and mask (H×W, uint8) formats. Returns (keypoints, descriptors) tuple.</description>
    </interface>
    <interface>
      <name>FeatureExtractor.set_baseline</name>
      <kind>method</kind>
      <signature>set_baseline(self, image: np.ndarray, mask: np.ndarray) -&gt; None</signature>
      <path>src/feature_extractor.py (to be created)</path>
      <description>Capture and store baseline features. Calls extract_features() then validates feature count ≥ min_features_required. Raises ValueError if insufficient features. Stores baseline as (keypoints, descriptors) tuple.</description>
    </interface>
    <interface>
      <name>FeatureExtractor.get_baseline</name>
      <kind>method</kind>
      <signature>get_baseline(self) -&gt; Tuple[List[cv2.KeyPoint], np.ndarray]</signature>
      <path>src/feature_extractor.py (to be created)</path>
      <description>Return stored baseline features. Raises RuntimeError if baseline not set (baseline_features is None). Returns (keypoints, descriptors) tuple.</description>
    </interface>
    <interface>
      <name>cv2.ORB_create</name>
      <kind>function</kind>
      <signature>cv2.ORB_create(nfeatures=500, ...) -&gt; cv2.ORB</signature>
      <path>opencv-python library</path>
      <description>Creates ORB feature detector with configurable parameters. Use default parameters for MVP (can be tuned later if needed).</description>
    </interface>
    <interface>
      <name>ORB.detectAndCompute</name>
      <kind>method</kind>
      <signature>detectAndCompute(image, mask=None) -&gt; Tuple[List[cv2.KeyPoint], np.ndarray]</signature>
      <path>opencv-python library</path>
      <description>Detects keypoints and computes descriptors in a single call. Mask parameter (H×W, uint8) restricts detection to areas where mask==255. Returns (keypoints, descriptors).</description>
    </interface>
  </interfaces>

  <tests>
    <standards>Use pytest framework with Arrange-Act-Assert pattern. Create helper functions for test setup (e.g., create_test_image, create_feature_rich_image, create_feature_poor_image). Target &gt;80% code coverage. Write descriptive test names that explain what is being tested. Use pytest.raises() for exception testing with match parameter for error message validation. Follow patterns from test_static_region_manager.py for consistency.</standards>
    <locations>tests/test_feature_extractor.py</locations>
    <ideas>
      <idea ac="1.2.1">
        <test>test_extract_features_success - Verify ORB features extracted successfully with valid image and mask</test>
        <test>test_extract_features_returns_correct_types - Verify return types (list of KeyPoints, np.ndarray descriptors)</test>
        <test>test_extract_features_respects_mask - Verify features only detected in masked region (255 areas)</test>
      </idea>
      <idea ac="1.2.2">
        <test>test_set_baseline_success - Verify baseline stored correctly with sufficient features</test>
        <test>test_get_baseline_returns_stored_features - Verify get_baseline() returns same features set by set_baseline()</test>
        <test>test_set_baseline_overwrites_previous - Verify calling set_baseline() multiple times overwrites previous baseline</test>
      </idea>
      <idea ac="1.2.3">
        <test>test_set_baseline_insufficient_features - Verify ValueError raised when feature count &lt; 50</test>
        <test>test_set_baseline_exactly_50_features - Boundary case: exactly 50 features should succeed</test>
        <test>test_set_baseline_error_message_shows_count - Verify error message includes actual vs required feature count</test>
      </idea>
      <idea ac="1.2.4">
        <test>test_extract_features_with_different_masks - Test extraction with various mask patterns (small, large, irregular)</test>
        <test>test_extract_features_with_textured_image - Use image with known feature-rich content (checkerboard, text)</test>
      </idea>
      <idea ac="1.2.5">
        <test>test_extract_features_invalid_image_shape - Verify ValueError for wrong image dimensions (not H×W×3)</test>
        <test>test_extract_features_invalid_image_dtype - Verify ValueError for wrong dtype (not uint8)</test>
        <test>test_extract_features_invalid_mask_shape - Verify ValueError for wrong mask dimensions (not H×W)</test>
        <test>test_extract_features_invalid_mask_dtype - Verify ValueError for wrong mask dtype (not uint8)</test>
        <test>test_extract_features_dimension_mismatch - Verify ValueError when mask dimensions don't match image</test>
        <test>test_get_baseline_not_set - Verify RuntimeError when get_baseline() called before set_baseline()</test>
      </idea>
    </ideas>
  </tests>
</story-context>
