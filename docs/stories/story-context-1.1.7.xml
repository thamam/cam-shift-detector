<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story_id>1.7</story_id>
    <story_title>Recalibration Script</story_title>
    <epic_id>MVP-001</epic_id>
    <project_name>cam-shift-detector</project_name>
    <created>2025-10-23</created>
    <phase>Implementation</phase>
    <design_principle>THIN CLI WRAPPER - All validation and logic delegated to intrinsic CameraMovementDetector.recalibrate() method</design_principle>
    <dependencies>
      <dependency story_id="1.5" component="CameraMovementDetector" status="complete">
        Intrinsic recalibrate() method - ALL LOGIC LIVES HERE
      </dependency>
      <dependency story_id="1.1" component="StaticRegionManager" status="complete">
        Config schema reference (consumed by detector initialization)
      </dependency>
    </dependencies>
  </metadata>

  <story>
    <as_a>DAF system operator</as_a>
    <i_want>manually recalibrate the camera movement detector baseline using a CLI tool</i_want>
    <so_that>I can quickly reset the baseline features after lighting changes, maintenance, or camera repositioning without restarting the entire detection system</so_that>
  </story>

  <artifacts>
    <artifact id="tech-spec-recalibration-workflow" type="technical-specification">
      <source>docs/tech-spec-epic-MVP-001.md</source>
      <section>Workflows and Sequencing - Manual Recalibration Workflow</section>
      <content>
**Manual Recalibration Workflow**:
```
Trigger: Lighting change, maintenance, operator decision

1. Operator runs: python tools/recalibrate.py
   OR calls: detector.recalibrate(current_image)

2. Module:
   - Generates binary mask for static region (using existing config)
   - Extracts new ORB features (with mask)
   - Validates ≥50 features detected
   - Replaces baseline_features in memory
   - Optionally clears history buffer

3. Returns: success (True) or failure (False)

4. Resume normal detection
```

**Key Points**:
- Script is optional CLI convenience wrapper
- Core recalibrate() method is intrinsic to CameraMovementDetector (Story 1.5)
- Uses existing config.json (no config generation)
- Validates same ≥50 feature requirement as initial setup
      </content>
    </artifact>

    <artifact id="tech-spec-services-modules" type="technical-specification">
      <source>docs/tech-spec-epic-MVP-001.md</source>
      <section>Services and Modules</section>
      <content>
**Recalibration Script**
- File: `tools/recalibrate.py`
- Responsibility: Manual baseline reset helper
- Inputs: TBD (define during story creation) → Now defined: --config, --image, --clear-history
- Outputs: Success/failure status
- Owner: Utility

**Design**: Thin wrapper around CameraMovementDetector.recalibrate() intrinsic method. NO validation logic in script.
      </content>
    </artifact>

    <artifact id="camera-movement-detector-recalibrate-method" type="code-reference">
      <source>src/camera_movement_detector.py</source>
      <component>CameraMovementDetector</component>
      <purpose>Intrinsic recalibration method - ALL VALIDATION AND LOGIC</purpose>
      <key_methods>
        <method name="recalibrate">
          <signature>def recalibrate(self, image_array: np.ndarray) -> bool</signature>
          <description>Manually reset baseline features (intrinsic method)</description>
          <implementation_lines>294-320</implementation_lines>
          <logic>
This method contains ALL recalibration logic:
- Validates image format via _validate_image_format()
- Generates binary mask using region_manager.get_static_mask()
- Calls set_baseline() which:
  - Extracts ORB features via feature_extractor
  - Validates ≥50 features detected
  - Replaces baseline_features in memory
- Returns True if successful, False if insufficient features
          </logic>
          <returns>
            - True: Recalibration successful (≥50 features detected)
            - False: Insufficient features (&lt;50) or invalid image format
          </returns>
        </method>
      </key_methods>
      <usage_pattern>
```python
# The ONLY logic needed in recalibrate.py script:
detector = CameraMovementDetector('config.json')
success = detector.recalibrate(new_image_array)  # ← ALL LOGIC HERE

if success:
    print("✓ Recalibration successful")
    sys.exit(0)
else:
    print("✗ Recalibration failed: Insufficient features")
    sys.exit(1)
```
      </usage_pattern>
    </artifact>

    <artifact id="select-roi-tool-reference" type="code-reference">
      <source>tools/select_roi.py</source>
      <component>ROI Selection Tool (Story 1.6)</component>
      <purpose>Reference implementation for CLI tool structure</purpose>
      <patterns_to_reuse>
- argparse CLI structure (--config, --image arguments)
- load_image() function for image I/O with error handling
- FileNotFoundError and ValueError exception handling
- Success/failure exit codes (0=success, 1=failure)
- Simple console output with ✓/✗ symbols
- Executable shebang and main() guard
      </patterns_to_reuse>
      <key_differences>
- recalibrate.py is SIMPLER (no feature validation logic)
- recalibrate.py calls detector.recalibrate() instead of FeatureExtractor directly
- recalibrate.py loads existing config instead of generating it
      </key_differences>
    </artifact>

    <artifact id="config-json-schema" type="data-model">
      <source>src/static_region_manager.py</source>
      <schema_reference>StaticRegionManager config validation</schema_reference>
      <content>
**Config Schema** (consumed by CameraMovementDetector):
```json
{
  "roi": {
    "x": 100,
    "y": 50,
    "width": 400,
    "height": 300
  },
  "threshold_pixels": 2.0,
  "history_buffer_size": 100,
  "min_features_required": 50
}
```

**Script Usage**: Read-only - script passes config path to CameraMovementDetector.__init__()
**Validation**: Handled by CameraMovementDetector._validate_config() (not script)
      </content>
    </artifact>
  </artifacts>

  <interfaces>
    <interface type="cli-tool">
      <name>Recalibration Script</name>
      <command>python tools/recalibrate.py --config &lt;config_path&gt; --image &lt;image_path&gt; [--clear-history]</command>
      <arguments>
        <argument name="--config" required="true" type="string">
          <description>Path to config.json file</description>
          <validation>File must exist (simple check, no schema validation in script)</validation>
        </argument>
        <argument name="--image" required="true" type="string">
          <description>Path to new reference image for baseline reset</description>
          <validation>File must exist and be loadable by cv2.imread()</validation>
        </argument>
        <argument name="--clear-history" required="false" type="flag">
          <description>Clear detection history buffer after successful recalibration</description>
          <default>False</default>
        </argument>
      </arguments>
      <outputs>
        <output type="stdout">
          <success_message>✓ Recalibration successful at {timestamp}\n[✓ Detection history buffer cleared]</success_message>
          <failure_message>✗ Recalibration failed at {timestamp}\nReason: Insufficient features detected in ROI (&lt;50 required)\nAction: Try a different image with more texture/features in the ROI</failure_message>
        </output>
        <output type="exit-code">
          <success>0</success>
          <failure>1</failure>
        </output>
      </outputs>
      <error_handling>
        <error type="FileNotFoundError">
          <message>Error: Config file not found: {config_path}</message>
          <exit_code>1</exit_code>
        </error>
        <error type="FileNotFoundError">
          <message>Error: Image file not found: {image_path}</message>
          <exit_code>1</exit_code>
        </error>
        <error type="ValueError">
          <message>Error: Failed to load image from {image_path}. File may be corrupted.</message>
          <exit_code>1</exit_code>
        </error>
      </error_handling>
    </interface>

    <interface type="intrinsic-method">
      <name>CameraMovementDetector.recalibrate()</name>
      <signature>def recalibrate(self, image_array: np.ndarray) -> bool</signature>
      <location>src/camera_movement_detector.py:294-320</location>
      <responsibility>ALL recalibration validation and logic</responsibility>
      <delegation_chain>
        recalibrate() calls:
        ├─→ _validate_image_format(image_array)  [validates H×W×3, uint8, BGR]
        ├─→ set_baseline(image_array)            [delegates to components below]
        │   ├─→ region_manager.get_static_mask() [generates binary mask from config]
        │   ├─→ feature_extractor.set_baseline() [extracts ORB, validates ≥50 features]
        │   └─→ Raises ValueError if &lt;50 features
        └─→ Returns True (success) or False (caught ValueError)
      </delegation_chain>
      <script_integration>
```python
# Script calls this method - NO validation logic in script
detector = CameraMovementDetector(config_path)
success = detector.recalibrate(image_array)
```
      </script_integration>
    </interface>

    <interface type="history-buffer-access">
      <name>ResultManager.history</name>
      <location>src/result_manager.py</location>
      <access_pattern>detector.result_manager.history.clear()</access_pattern>
      <purpose>Optional history clearing after successful recalibration</purpose>
      <usage>
```python
if success and args.clear_history:
    detector.result_manager.history.clear()
    print("✓ Detection history buffer cleared")
```
      </usage>
    </interface>
  </interfaces>

  <constraints>
    <constraint type="design-principle" priority="critical">
**THIN CLI WRAPPER** - Script must contain ZERO validation logic. All intelligence remains in CameraMovementDetector.recalibrate() intrinsic method.
    </constraint>

    <constraint type="implementation">
Script responsibilities LIMITED to:
- CLI argument parsing (argparse)
- Image I/O (cv2.imread with basic error handling)
- Detector initialization (pass config to CameraMovementDetector)
- Method invocation (call detector.recalibrate())
- Result reporting (print success/failure, exit with code)
    </constraint>

    <constraint type="code-size">
Target: ~50-70 lines total (mostly boilerplate)
- Compare to select_roi.py (230 lines) which has more complex logic
- recalibrate.py should be SIMPLER since it delegates everything
    </constraint>

    <constraint type="logic-delegation">
NO logic allowed in script:
- ✗ NO feature extraction
- ✗ NO feature counting/validation
- ✗ NO mask generation
- ✗ NO config schema validation
- ✓ ONLY: parse args, load image, call method, print result
    </constraint>

    <constraint type="error-handling">
Minimal error handling in script:
- Check config file exists (Path.exists)
- Handle cv2.imread() returning None (corrupted image)
- Catch generic Exception from detector initialization
- All other errors handled by intrinsic method
    </constraint>
  </constraints>

  <testing_standards>
    <framework>pytest</framework>
    <coverage_target>80%</coverage_target>

    <test_categories>
      <category name="CLI Interface Testing">
        <description>Argument parsing and validation</description>
        <test_ideas>
          <test>Test --config and --image arguments parsed correctly</test>
          <test>Test --clear-history flag optional and defaults to False</test>
          <test>Test --help displays usage instructions</test>
          <test>Test missing required arguments raises SystemExit</test>
        </test_ideas>
      </category>

      <category name="Recalibration Success">
        <description>Valid recalibration with feature-rich image</description>
        <test_ideas>
          <test>Test recalibration with valid config and image containing ≥50 features</test>
          <test>Test exit code 0 on successful recalibration</test>
          <test>Test success message printed to stdout</test>
          <test>Test timestamp included in success message</test>
        </test_ideas>
      </category>

      <category name="Recalibration Failure">
        <description>Recalibration fails with insufficient features</description>
        <test_ideas>
          <test>Test recalibration with blank/feature-poor image (&lt;50 features)</test>
          <test>Test exit code 1 on recalibration failure</test>
          <test>Test failure message with reason printed to stdout</test>
          <test>Test guidance message suggests trying different image</test>
        </test_ideas>
      </category>

      <category name="History Clearing">
        <description>Optional history buffer clearing functionality</description>
        <test_ideas>
          <test>Test --clear-history flag clears buffer after successful recalibration</test>
          <test>Test history NOT cleared if flag not provided</test>
          <test>Test history clearing message printed when flag used</test>
          <test>Test history NOT cleared on recalibration failure</test>
        </test_ideas>
      </category>

      <category name="Error Handling">
        <description>Missing files, corrupted images, invalid config</description>
        <test_ideas>
          <test>Test missing config file raises clear error with exit code 1</test>
          <test>Test missing image file raises clear error with exit code 1</test>
          <test>Test corrupted image file (cv2.imread returns None) raises error</test>
          <test>Test invalid config schema handled by detector (not script)</test>
        </test_ideas>
      </category>

      <category name="Integration with Intrinsic Method">
        <description>Verify proper delegation to detector.recalibrate()</description>
        <test_ideas>
          <test>Test script calls detector.recalibrate() with loaded image</test>
          <test>Test script respects boolean return value from method</test>
          <test>Test script does NOT perform any validation itself</test>
          <test>Mock detector.recalibrate() and verify script behavior</test>
        </test_ideas>
      </category>
    </test_categories>

    <standards>
**Test Framework**: pytest with fixtures for config/image paths

**Test Patterns**:
- Mock CameraMovementDetector for unit tests (avoid full detector initialization)
- Use temporary directories for config files (tmp_path fixture)
- Mock cv2.imread for controlled image loading scenarios
- Capture stdout to verify printed messages (capsys fixture)
- Test both success and failure paths for all operations

**Coverage Focus**:
- main() function: all branches (success/failure/errors)
- parse_arguments(): all argument combinations
- load_image(): valid/missing/corrupted scenarios
- Exit code verification: 0 for success, 1 for all failures

**Integration Test**:
One end-to-end test with real CameraMovementDetector to verify full workflow
    </standards>
  </testing_standards>

  <implementation_guidance>
    <file_structure>
      <location>tools/recalibrate.py</location>
      <directory_creation>tools/ directory already exists (from Story 1.6)</directory_creation>
      <dependencies>
        - argparse (Python stdlib)
        - sys (Python stdlib)
        - datetime (Python stdlib)
        - pathlib (Python stdlib)
        - cv2 (OpenCV) - only for cv2.imread()
        - src.camera_movement_detector (existing component)
      </dependencies>
    </file_structure>

    <code_structure>
      <functions>
        <function name="parse_arguments">
          <purpose>Parse CLI arguments with argparse</purpose>
          <returns>argparse.Namespace</returns>
        </function>

        <function name="load_image">
          <signature>def load_image(image_path: str) -> np.ndarray</signature>
          <purpose>Load image from file path (simple I/O wrapper)</purpose>
          <raises>FileNotFoundError, ValueError</raises>
        </function>

        <function name="main">
          <purpose>Main execution flow - THIN wrapper only</purpose>
          <flow>
1. Parse arguments
2. Validate config file exists (simple Path check)
3. Load image (handle I/O errors)
4. Initialize detector (pass config to CameraMovementDetector)
5. Call detector.recalibrate(image) ← ALL LOGIC HERE
6. Print result based on boolean return
7. Optionally clear history if flag set
8. Exit with appropriate code
          </flow>
        </function>
      </functions>

      <minimal_implementation>
Script should be ~50-70 lines:
- ~15 lines: imports and argparse setup
- ~10 lines: load_image() function
- ~35 lines: main() with error handling
- ~5 lines: if __name__ == "__main__" guard

Compare to select_roi.py (230 lines with complex validation) - this should be MUCH simpler.
      </minimal_implementation>
    </code_structure>

    <key_implementation_notes>
      <note priority="critical">
NO validation logic in script. The detector.recalibrate() method handles:
- Image format validation (_validate_image_format)
- Mask generation (region_manager.get_static_mask)
- Feature extraction (feature_extractor.set_baseline)
- Feature count validation (≥50 requirement)
      </note>

      <note priority="high">
Reuse patterns from select_roi.py:
- argparse structure for CLI arguments
- load_image() error handling (FileNotFoundError, ValueError)
- Success/failure output formatting with ✓/✗ symbols
- Exit code convention (0=success, 1=failure)
      </note>

      <note priority="high">
History clearing is OPTIONAL feature:
- Only clear if --clear-history flag provided
- Only clear on successful recalibration (not failure)
- Simple access: detector.result_manager.history.clear()
      </note>

      <note priority="medium">
Error messages should guide operators:
- Missing file: Clear "not found" message with path
- Recalibration failure: Explain insufficient features, suggest trying different image
- Include timestamps in success/failure messages for logging
      </note>
    </key_implementation_notes>

    <reference_implementation>
The story file (story-1.7.md) contains a complete reference implementation in the Dev Notes section (lines 113-212) showing the thin wrapper pattern with ALL logic delegated to detector.recalibrate().

Key pattern from reference:
```python
# Initialize detector (delegates validation to CameraMovementDetector)
detector = CameraMovementDetector(args.config)

# Call intrinsic method - ALL validation happens here
success = detector.recalibrate(image)  # ← ALL LOGIC IN THIS METHOD

# Report result (simple output formatting)
if success:
    print("✓ Recalibration successful")
    if args.clear_history:
        detector.result_manager.history.clear()
    sys.exit(0)
else:
    print("✗ Recalibration failed")
    sys.exit(1)
```
    </reference_implementation>
  </implementation_guidance>

  <acceptance_criteria_mapping>
    <ac id="AC-1.7.1" description="CLI Interface">
      <test_coverage>
        - parse_arguments() with --config, --image, --clear-history
        - Argument validation (required vs optional)
        - --help text display
      </test_coverage>
      <implementation_files>tools/recalibrate.py (parse_arguments function)</implementation_files>
    </ac>

    <ac id="AC-1.7.2" description="Config Loading">
      <test_coverage>
        - Config file existence check
        - Pass config path to CameraMovementDetector.__init__()
        - Config validation handled by detector (not script)
      </test_coverage>
      <implementation_files>tools/recalibrate.py (main function)</implementation_files>
    </ac>

    <ac id="AC-1.7.3" description="Image Loading">
      <test_coverage>
        - load_image() loads valid image successfully
        - Handles missing image file (FileNotFoundError)
        - Handles corrupted image (cv2.imread returns None)
      </test_coverage>
      <implementation_files>tools/recalibrate.py (load_image function)</implementation_files>
    </ac>

    <ac id="AC-1.7.4" description="Baseline Reset">
      <test_coverage>
        - Script calls detector.recalibrate(image)
        - NO validation logic in script (delegated to method)
        - Method handles all baseline reset logic
      </test_coverage>
      <implementation_files>tools/recalibrate.py (main function calling detector.recalibrate)</implementation_files>
    </ac>

    <ac id="AC-1.7.5" description="Feature Validation">
      <test_coverage>
        - Feature validation (≥50) handled by detector.recalibrate() intrinsic method
        - Script does NOT validate features directly
        - Script respects boolean return value from method
      </test_coverage>
      <implementation_files>src/camera_movement_detector.py (recalibrate method - intrinsic)</implementation_files>
    </ac>

    <ac id="AC-1.7.6" description="Success/Failure Reporting">
      <test_coverage>
        - Success message with timestamp on True return
        - Failure message with reason on False return
        - Exit code 0 for success, 1 for failure
      </test_coverage>
      <implementation_files>tools/recalibrate.py (main function result handling)</implementation_files>
    </ac>

    <ac id="AC-1.7.7" description="Error Handling">
      <test_coverage>
        - Missing config file error
        - Missing/corrupted image file error
        - Detector initialization errors
        - Clear error messages for all cases
      </test_coverage>
      <implementation_files>tools/recalibrate.py (main function error handling)</implementation_files>
    </ac>

    <ac id="AC-1.7.8" description="History Buffer Handling">
      <test_coverage>
        - --clear-history flag clears buffer on success
        - History NOT cleared if flag not provided
        - History NOT cleared on failure
        - Clear message when clearing history
      </test_coverage>
      <implementation_files>tools/recalibrate.py (main function history clearing logic)</implementation_files>
    </ac>
  </acceptance_criteria_mapping>

  <notes>
    <note type="design-philosophy">
This script is a **maintenance convenience tool** - the core recalibration functionality is intrinsic to the CameraMovementDetector class. Operators can choose to use the script OR call detector.recalibrate() directly from code.
    </note>

    <note type="implementation">
The script is intentionally minimal (~50-70 lines) to emphasize the thin wrapper pattern. All validation, feature extraction, and business logic remains in the detector class where it belongs.
    </note>

    <note type="testing">
Testing strategy focuses on:
1. CLI interface correctness (arg parsing)
2. Proper delegation to intrinsic method
3. Error handling for I/O failures
4. Exit code verification
Most complex testing happens in CameraMovementDetector tests (Story 1.5), not here.
    </note>

    <note type="integration">
The script integrates with three existing stories:
- Story 1.5: Provides intrinsic recalibrate() method (ALL LOGIC)
- Story 1.6: Generates config.json consumed by detector initialization
- Story 1.4: Provides history buffer access for optional clearing
    </note>
  </notes>
</story-context>
